; Support for RTL->C++ conversion.
;
; This code is an extension of rtl-c.scm, from which the main
; structure is reproduced here. The reason why we are replicating
; it here is because we could not find a (easy) way to replace 
; the code generated by rtl-c with our C++ one. The heavy use of 
; MACROS and CGEN related C code makes producing code in a different
; language hard.
; Another reason is that, possibly, future CGEN updates might change
; rtl-c.scm code making transitioning to the new version much harder.  
; Therefore we keep the same algorithms implemented
; in rtl-c.scm (whose quality has been already tested) and we change
; some minor things.
; The main addition to the 'rtl-c' code is the ability to switch the
; set of generators for the RTL semantic functions.
; This was added because during the application workflow we need to 
; emit some C++ code to evaluate RTL expression in place, while in some
; other places we need to emit C++ code to generate LLVM IR code 
; semantically equivalent to an RTL expression. Hence, to avoid ourself
; to write also a 'rtl-llvm.scm' module, we make RTL-function generators
; easily interchangeable.

; Generating C++ from RTL
; -----------------------
; The main ways to generate C++ code from RTL expression are:
;
; (rtl-cpp mode '(func mode ...) nil)
;   and
; (rtl-llvm mode '(func mode ...) nil))
;
; rtl-cpp in case we want to emit C++ code to evaluate in place the
; expression contained in FUNC.
; rtl-llvm in case we want to emit C++ code to generate LLVM IR code
; semantically equivalent to the expression contained in FUNC. 
; 
; The rest of this entry comment is taken from the rtl-c.scm one as
; it fits nicely:
; ============ FROM CGEN / rtl-c.scm ============
; The expression is in source form or may be already compiled (with
; rtx-compile).
;
; The `set' rtx needs to be handled a little carefully.
; Both the dest and src are processed first, and then code to perform the
; assignment is computed.  However, the dest may require more than a simple
; C++ assignment.  Therefore set dests are converted to the specified object
; (e.g. a hardware operand) and then a message is sent to this object to
; perform the actual code generation.
;
; All interesting operands (e.g. regs, mem) are `operand' objects.
; The following messages must be supported by operand objects.
; - get-mode      - return mode of operand
; - cxmake-get    - return <cpp-expr> object containing operand's value
; - gen-set-quiet - return string of C++ code to set operand's value (no tracing)
; - gen-set-trace - return string of C++ code to set operand's value
;
; Instruction fields are refered to by name.
; (estate-owner estate) must be an instruction that has the field.
; Instruction ifields must have these methods:
; - get-mode
; - cxmake-get
;
; Conventions used in this file:
; - see rtl.scm

; The <cpp-expr> object.
; This is a fully translated expression (i.e. C++ code).

(define <cpp-expr>
  (class-make '<cpp-expr> nil
        '(
    ; The mode of CPP-CODE.
    mode
    ; The translated C++ code.
    cpp-code
    ; The source expression, for debugging.
    expr
    ; Attributes of the expression.
    atlist
    ; List of temporaries required to compute the expression.
    ; ??? wip.  These would be combined as the expression is
    ; built up.  Then in sets and other statements, the temporaries
    ; would be declared.
    ;(tmps . nil)
    )
        nil)
)

(method-make!
 <cpp-expr> 'make!
 (lambda (self mode cpp-code atlist)
   ; FIXME: Extend COS to allow specifying member predicates.
   (assert (mode? mode))
   (assert (string? cpp-code))
   ;(assert (atlist? atlist)) ; FIXME: What should this be?
   (elm-set! self 'mode mode)
   (elm-set! self 'cpp-code cpp-code)
   (elm-set! self 'atlist atlist)
   self)
)

; Accessor fns

(define cx:mode (elm-make-getter <cpp-expr> 'mode))
(define cx:cpp-code (elm-make-getter <cpp-expr> 'cpp-code))
(define cx:expr (elm-make-getter <cpp-expr> 'expr))
(define cx:atlist (elm-make-getter <cpp-expr> 'atlist))

; Any object with attributes requires the get-atlist method.

(method-make! <cpp-expr> 'get-atlist (lambda (self) (elm-get self 'atlist)))

; Respond to 'get-mode messages.

(method-make! <cpp-expr> 'get-mode (lambda (self) (elm-get self 'mode)))

; Respond to 'get-name messages for rtx-dump.

(method-make!
 <cpp-expr> 'get-name
 (lambda (self)
   (string-append "(" (obj:str-name (elm-get self 'mode)) ") "
      (cx:cpp self)))
)

; Return C++ code to perform an assignment.
; NEWVAL is a <cpp-expr> object of the value to be assigned to SELF.

(method-make! <cpp-expr> 'gen-set-quiet
        (lambda (self estate mode indx selector newval)
    (string-append "  " (cx:cpp self) " = " (cx:cpp newval) ";\n"))
)

(method-make! <cpp-expr> 'gen-set-trace
        (lambda (self estate mode indx selector newval)
    (string-append "  " (cx:cpp self) " = " (cx:cpp newval) ";\n"))
)

; Return the C++ code of CX.
; ??? This used to handle lazy evaluation of the expression.
; Maybe it will again, so it's left in, as a cover fn to cx:cpp-code.

(define (cx:cpp cx)
  (cx:cpp-code cx)
)

; Main routine to create a <cpp-expr> node object.
; MODE is either the mode's symbol (e.g. 'QI) or a mode object.
; CODE is a string of C++ code.

(define (cx:make mode code)
  (make <cpp-expr> (mode:lookup mode) code nil)
)

; Make copy of CX in new mode MODE.
; MODE must be a <mode> object.

(define (cx-new-mode mode cx)
  (make <cpp-expr> mode (cx:cpp cx) (cx:atlist cx))
)

; Same as cx:make except with attributes.

(define (cx:make-with-atlist mode code atlist)
  (make <cpp-expr> (mode:lookup mode) code atlist)
)

; Return a boolean indicated if X is a <cpp-expr> object.

(define (cpp-expr? x) (class-instance? <cpp-expr> x))

; RTX environment support.

(method-make!
 <rtx-temp> 'cxmake-get
 (lambda (self estate mode indx selector)
   (cx:make mode (rtx-temp-value self)))
)

(method-make!
 <rtx-temp> 'gen-set-quiet
 (lambda (self estate mode indx selector src)
   (string-append "  " (rtx-temp-value self) " = " (cx:cpp src) ";\n"))
)

(method-make!
 <rtx-temp> 'gen-set-trace
 (lambda (self estate mode indx selector src)
   (string-append "  " (rtx-temp-value self) " = " (cx:cpp src) ";\n"))
)

(define (gen-temp-defs estate env)
  (string-map (lambda (temp)
    (let ((temp-obj (cdr temp)))
      (string-append "  " (gen-mode-cpp-type (rtx-temp-mode temp-obj))
         " " (rtx-temp-value temp-obj) ";\n")))
        env)
)

; Top level routines to handle rtl->cpp translation.

; Subclass of <eval-state> to record additional things needed for rtl->c++.

(define <rtl-cpp-eval-state>
  (class-make '<rtl-cpp-eval-state> '(<eval-state>)
        '(
    ; specifies the semantic type of code to generate.
    ; "cpp" -> emits cpp code that evaluates the expression
    ; "llvm" -> emits cpp code that performs LLVM IR code 
    ;           generation semantically equivalent to the expression
    (semantic-type . "cpp")

    ; ===== LEFT TEMPORARLY. WE'LL SEE IF WE NEED IT =====
    ; #f -> reference ifield values using FLD macro.
    ; #t -> use C variables.
    ; ??? This is only needed to get correct ifield references
    ; in opcodes, decoder, and semantics.  Maybe a better way to
    ; go would be to specify the caller's name so there'd be just
    ; one of these, rather than an increasing number.  However,
    ; for now either way is the same.
    ; An alternative is to specify a callback to try first.
    (ifield-var? . #f)
    )
        nil)
)

; FIXME: involves upcasting.
(define-getters <rtl-cpp-eval-state> estate
  (semantic-type ifield-var?)
)

; Return booleans indicating if semantic type is "cpp" or "llvm"

(define (estate-semantic-type-cpp? estate)
  (string=? (estate-semantic-type estate) "cpp")
)
(define (estate-semantic-type-llvm? estate)
  (string=? (estate-semantic-type estate) "llvm")
)

(method-make!
 <rtl-cpp-eval-state> 'vmake!
 (lambda (self args)
   ; Initialize parent class first.
   (let loop ((args (send-next self 'vmake! args)) (unrecognized nil))
     (if (null? args)
   (reverse! unrecognized) ; ??? Could invoke method to initialize here.
   (begin
     (case (car args)
       ((#:semantic-type)
        (elm-set! self 'semantic-type (cadr args)))
       ((#:ifield-var?)
        (elm-set! self 'ifield-var? (cadr args)))
       (else
        ; Build in reverse order, as we reverse it back when we're done.
        (set! unrecognized
        (cons (cadr args) (cons (car args) unrecognized)))))
     (loop (cddr args) unrecognized)))))
)

; Build an estate for use in generating CPP.
; CONTEXT is a <context> object or #f if there is none.
; OWNER is the owner of the expression or #f if there is none.
; EXTRA-VARS-ALIST is an association list of (symbol <mode> value)
;   elements to be used during value lookup.
; OVERRIDES is a #:keyword/value list of parameters to apply last.

(define (estate-make-for-rtl-cpp context owner extra-vars-alist
          semantic-type overrides)
  (let ((generator (cond 
          ((estate-semantic-type-cpp? semantic-type) 'rtl-cpp-generator)
          ((estate-semantic-type-llvm? semantic-type) 'rtl-llvm-generator)
          (else 'rtl-cpp-generator))))
    (apply vmake
      (append!
        (list
         <rtl-c-eval-state>
         #:context context
         #:owner owner
         #:expr-fn (lambda (rtx-obj expr mode estate)
               (generator rtx-obj))
         #:env (rtx-env-init-stack1 extra-vars-alist)
        )
      overrides)
    )
  )

)

; ============ SEMANTIC-TYPE: CPP ============

(define (estate-make-for-normal-rtl-cpp extra-vars-alist overrides)
  (estate-make-for-rtl-c
   #f ; FIXME: context
   #f ; FIXME: owner
   extra-vars-alist
   "cpp" ; Semantic-type
   overrides)
)

; Translate RTL expression EXPR to CPP.
; ESTATE is the current rtx evaluation state.

(define (rtl-cpp-with-estate estate mode expr)
  (cx:cpp (rtl-cpp-get estate mode (rtx-eval-with-estate expr mode estate)))
)

; Translate parsed RTL expression X to a string of CPP code.
; X must have already been fed through rtx-parse/rtx-compile.
; MODE is the desired mode of the value or DFLT for "natural mode".
; EXTRA-VARS-ALIST is an association list of extra (symbol <mode> value)
; elements to be used during value lookup.
; OVERRIDES is a #:keyword/value list of arguments to build the eval state
; with.

(define (rtl-cpp-parsed mode x extra-vars-alist . overrides)
  (let ((estate (estate-make-for-normal-rtl-cpp extra-vars-alist overrides)))
    (rtl-cpp-with-estate estate mode x))
)

; Same as rtl-cpp-parsed but X is unparsed.

(define (rtl-cpp mode x extra-vars-alist . overrides)
  ; ??? rtx-compile could return a closure, then we wouldn't have to
  ; pass EXTRA-VARS-ALIST to two routines here.
  (let ((estate (estate-make-for-normal-rtl-cpp extra-vars-alist overrides)))
    (rtl-cpp-with-estate estate mode (rtx-compile #f x extra-vars-alist)))
)

; Same as rtl-cpp-with-estate except return a <cpp-expr> object.

(define (rtl-cpp-expr-with-estate estate mode expr)
  (rtl-cpp-get estate mode (rtx-eval-with-estate expr mode estate))
)

; Same as rtl-cpp-parsed except return a <cpp-expr> object.

(define (rtl-cpp-expr-parsed mode x extra-vars-alist . overrides)
  (let ((estate (estate-make-for-normal-rtl-cpp extra-vars-alist overrides)))
    (rtl-cpp-expr-with-estate estate mode x))
)

; Same as rtl-cpp-expr-parsed but X is unparsed.

(define (rtl-cpp-expr mode x extra-vars-alist . overrides)
  ; ??? rtx-compile could return a closure, then we wouldn't have to
  ; pass EXTRA-VARS-ALIST to two routines here.
  (let ((estate (estate-make-for-normal-rtl-cpp extra-vars-alist overrides)))
    (rtl-cpp-expr-with-estate estate mode (rtx-compile #f x extra-vars-alist)))
)

; ============ SEMANTIC-TYPE: LLVM ============
; LLVM IR versions of rtl-cpp routines 

; Build an estate for use in generating LLVM IR.
; EXTRA-VARS-ALIST is an association list of (symbol <mode> value)
; elements to be used during value lookup.
; OVERRIDES is a #:keyword/value list of parameters to apply last.

(define (estate-make-for-normal-rtl-llvm extra-vars-alist overrides)
  (estate-make-for-rtl-cpp
   #f ; FIXME: context
   #f ; FIXME: owner
   extra-vars-alist
   "llvm"
   overrides)
)

; Translate parsed RTL expression X to a string of C++ code emitting LLVM IR
; X must have already been fed through rtx-parse/rtx-compile.
; MODE is the desired mode of the value or DFLT for "natural mode".
; EXTRA-VARS-ALIST is an association list of extra (symbol <mode> value)
; elements to be used during value lookup.
; OVERRIDES is a #:keyword/value list of arguments to build the eval state
; with.
; ??? Maybe EXTRA-VARS-ALIST should be handled this way.

(define (rtl-llvm-parsed mode x extra-vars-alist . overrides)
  (let ((estate (estate-make-for-normal-rtl-llvm extra-vars-alist overrides)))
    (rtl-cpp-with-estate estate mode x))
)

; Same as rtl-llvm-parsed but X is unparsed.

(define (rtl-llvm mode x extra-vars-alist . overrides)
  ; ??? rtx-compile could return a closure, then we wouldn't have to
  ; pass EXTRA-VARS-ALIST to two routines here.
  (let ((estate (estate-make-for-normal-rtl-llvm extra-vars-alist overrides)))
    (rtl-cpp-with-estate estate mode (rtx-compile #f x extra-vars-alist)))
)

; Top level routines for getting/setting values.

; Return a <cpp-expr> node to get the value of SRC in mode MODE.
; ESTATE is the current rtl evaluation state.
; SRC is one of:
; - <cpp-expr> node
; - rtl expression (e.g. '(add WI dr sr))
; - sequence's local variable name
; - sequence's local variable object
; - operand name
; - operand object
; - a string of CPP code
; FIXME: Reduce acceptable values of SRC.
; The result has mode MODE, unless MODE is the "default mode indicator"
; (DFLT) in which case the mode of the result is derived from SRC.
; If SRC is a string, MODE can't be VOID or DFLT.
;
; ??? mode compatibility checks are wip

(define (-rtl-cpp-get estate mode src)
  (let ((mode (mode:lookup mode)))

    (cond ((cpp-expr? src)
      (cond ((or  (mode:eq? 'VOID mode)
                  (mode:eq? 'DFLT mode)
                  (mode:eq? (cx:mode src) mode))
              src)
            ((-rtx-mode-compatible? mode (cx:mode src))
              (cx-new-mode mode src))
            (else
              (error (string-append "incompatible mode for "
                        "(" (obj:name (cx:mode src)) " vs " (obj:name mode) ") in "
                        "\"" (cx:c src) "\""
                        ": ")
                      (obj:name mode)
              )
            )
      ))

      ; The recursive call to -rtl-cpp-get is in case the result of rtx-eval
      ; is a hardware object, rtx-func object, or another rtl expression.
      ((rtx? src)
        (let ((evald-src (rtx-eval-with-estate src mode estate)))
          ; There must have been some change, otherwise we'll loop forever.
          (assert (not (eq? src evald-src)))
          (-rtl-cpp-get estate mode evald-src))
      )

      ((or (and (symbol? src) (current-op-lookup src))
           (operand? src))
        (begin
          (if (symbol? src)
            (set! src (current-op-lookup src))
          )
          (cond 
            ((mode:eq? 'DFLT mode)
            ; FIXME: If we fetch the mode here, operands can assume
            ; they never get called with "default mode".
              (send src 'cxmake-get estate mode #f #f)
            )
            ((-rtx-mode-compatible? mode (op:mode src))
              (let ((mode (-rtx-lazy-sem-mode mode)))
                (send src 'cxmake-get estate mode #f #f))
            )
            (else
              (error (string-append "operand " (obj:str-name src)
                  " referenced in incompatible mode: ")
                (obj:name mode))
            )
          )
        )
      )

      ((or (and (symbol? src) (rtx-temp-lookup (estate-env estate) src))
           (rtx-temp? src))
        (begin
          (if (symbol? src)
            (set! src (rtx-temp-lookup (estate-env estate) src))
          )
          (cond 
            ((mode:eq? 'DFLT mode)
              (send src 'cxmake-get estate (rtx-temp-mode src) #f #f)
            )
            ((-rtx-mode-compatible? mode (rtx-temp-mode src))
              (let ((mode (-rtx-lazy-sem-mode mode)))
                (send src 'cxmake-get estate mode #f #f))
            )
            (else 
              (error (string-append "sequence temp " (rtx-temp-name src)
                       " referenced in incompatible mode: ")
                (obj:name mode))
            )
          )
        )
      )

      ((integer? src)
        ; Default mode of string argument is INT.
        (if (or (mode:eq? 'DFLT mode) (mode:eq? 'VOID mode))
          (cx:make INT (number->string src))
          (cx:make mode (number->string src)))
      )

      ((string? src)
        ; Default mode of string argument is INT.
        (if (or (mode:eq? 'DFLT mode) (mode:eq? 'VOID mode))
          (cx:make INT src)
          (cx:make mode src))
      )

      (else (error "-rtl-cpp-get: invalid argument:" src))))
)

(define (rtl-cpp-get estate mode src)
  (logit 4 (spaces (estate-depth estate))
   "(rtl-cpp-get " (mode-real-name mode) " " (rtx-strdump src) ")\n")
  (let ((result (-rtl-cpp-get estate mode src)))
    (logit 4 (spaces (estate-depth estate))
     "(rtl-cpp-get " (mode-real-name mode) " " (rtx-strdump src) ") => "
     (cx:cpp result) "\n")
    result)
)

; Return a <cpp-expr> object to set the value of DEST to SRC.
; ESTATE is the current rtl evaluation state.
; DEST is one of:
; - <cpp-expr> node
; - rtl expression (e.g. '(mem QI dr))
; SRC is a <cpp-expr> object.
; The mode of the result is always VOID (void).

(define (rtl-cpp-set-quiet estate mode dest src)
  ;(display (list 'rtl-cpp-set-quiet mode dest src)) (newline)
  (let ((xdest 
          (cond 
            ((cpp-expr? dest) dest)
            ((rtx? dest)
              (rtx-eval-with-estate dest mode estate))
            (else
              (error "rtl-cpp-set-quiet: invalid dest:" dest))
          )
        ))
    (if (not (object? xdest))
      (error "rtl-cpp-set-quiet: invalid dest:" dest))
    (let ((mode (if (mode:eq? 'DFLT mode)
          (-rtx-obj-mode xdest)
          (-rtx-lazy-sem-mode mode))))
      (assert (mode? mode))
      (cx:make VOID 
        (send xdest 'gen-set-quiet estate mode #f #f
          (rtl-cpp-get estate mode src))
      )
    )
  )
)

; Same as rtl-cpp-set-quiet except also print TRACE_RESULT message.
; ??? One possible change is to defer the (rtl-cpp-get src) call to dest's
; set handler.  Such sources would be marked accordingly and rtl-cpp-get
; would recognize them.  This would allow, for example, passing the address
; of the result to the computation.

(define (rtl-cpp-set-trace estate mode dest src)
  ;(display (list 'rtl-cpp-set-quiet mode dest src)) (newline)
  (let ((xdest 
          (cond 
            ((cpp-expr? dest) dest)
            ((rtx? dest)
              (rtx-eval-with-estate dest mode estate))
            (else
              (error "rtl-cpp-set-trace: invalid dest:" dest))
          )
        ))
    (if (not (object? xdest))
      (error "rtl-cpp-set-trace: invalid dest:" dest))
    (let ((mode (if (mode:eq? 'DFLT mode)
          (-rtx-obj-mode xdest)
          (-rtx-lazy-sem-mode mode))))
      (assert (mode? mode))
      (cx:make VOID 
        (send xdest 'gen-set-trace estate mode #f #f
          (rtl-cpp-get estate mode src))
      )
    )
  )
)

; ============ SUPPORT for CODE GENERATORS ============


; This procedure is left unspecified while we decide how to handle external
; C/C++ code calls.
; ============ FROM CGEN / rtl-c.scm ============
; Support for explicit C/C++ code.
; ??? Actually, "support for explicit foreign language code".
; s-c-call needs a better name but "unspec" seems like obfuscation.
; ??? Need to distinguish owner of call (cpu, ???). 
(define (s-cpp-c-call estate mode name . args)
  *UNSPECIFIED*
)

; This procedure is left unspecified while we decide how to handle external
; C/C++ code calls.
; ============ FROM CGEN / rtl-c.scm ============
; Same as c-call except there is no particular owner of the call.
; In general this means making a call to a non-member function,
; whereas c-call makes calls to member functions (in C++ parlance).

(define (s-cpp-c-raw-call estate mode name . args)
  *UNSPECIFIED*
)

; Standard arithmetic operations.

; One operand referenced, result is in same mode.

(define (s-cpp-unop estate name cpp-op mode src semantic-type)
  (let* ((val (rtl-cpp-get estate mode src))
      ; Refetch mode in case it was DFLT and ensure unsigned->signed.
      (mode (cx:mode val))
      (sem-mode (-rtx-sem-mode mode)))

    (if (string=? semantic-type "cpp")
      (cx:make sem-mode
        (string-append "(" cpp-op " (" (cx:cpp val) "))")
      )   ; cpp sem-type
      (error "LLVM IR code generation not yet implemented")  ; llvm sem-type
    )
  )
)

; Two operands referenced in the same mode producing a result in the same mode.
; If MODE is DFLT, use the mode of SRC1.

(define (s-cpp-binop estate name cpp-op mode src1 src2 semantic-type)
  (let* ((val1 (rtl-cpp-get estate mode src1))
      ; Refetch mode in case it was DFLT and ensure unsigned->signed.
      (mode (cx:mode val1))
      (sem-mode (-rtx-sem-mode mode))
      (val2 (rtl-cpp-get estate mode src2)))

    (if (string=? semantic-type "cpp")
      (cx:make sem-mode 
        (string-append "((" (cx:cpp val1) ") " cpp-op " ("
          (cx:cpp val2) "))")
      )   ; cpp sem-type
      (error "LLVM IR code generation not yet implemented")  ; llvm sem-type
    )
  )
)

; Same as s-binop except there's a third argument which is always one bit.

(define (s-cpp-binop-with-bit estate name mode src1 src2 src3 semantic-type)
  (let* ((val1 (rtl-cpp-get estate mode src1))
      ; Refetch mode in case it was DFLT and ensure unsigned->signed.
      (mode (-rtx-sem-mode (cx:mode val1)))
      (val2 (rtl-cpp-get estate mode src2))
      (val3 (rtl-cpp-get estate 'BI src3)))

    (if (string=? semantic-type "cpp")
      (cx:make mode
        (string-append name
         " ("
         (cx:cpp val1) ", "
         (cx:cpp val2) ", "
         (cx:cpp val3)
         ")")
      )   ; cpp sem-type
      (error "LLVM IR code generation not yet implemented")  ; llvm sem-type
    )
  )
)

; Shift operations are slightly different than binary operations:
; the mode of src2 is any integral mode.
; ??? Note that some cpus have a signed shift left that is semantically
; different from a logical one.  May need to create `sla' some day.  Later.

(define (s-cpp-shop estate name cpp-op mode src1 src2 semantic-type)
  (let* ((val1 (rtl-cpp-get estate mode src1))
      ; Refetch mode in case it was DFLT and ensure unsigned->signed
      ; [sign of operation is determined from operation name, not mode].
      (mode (cx:mode val1))
      (sem-mode (-rtx-sem-mode mode))
      (val2 (rtl-cpp-get estate mode src2)))

    (if (string=? semantic-type "cpp")
      (cx:make sem-mode 
        (string-append "("
          ; Ensure correct sign on purpose
          (cond
            ((equal? name "SRL") 
              (string-append "static_cast<"
                (if (eq? (mode:class mode) 'UINT)
                  ""
                  "unsigned "
                )
                (mode:non-mode-c-type mode)
                ">("
              )
            )
            ((equal? name "SRA")
              (string-append "static_cast<"
                (mode:non-mode-c-type mode)
                ">("
              )
            )
            (else "(")
          )
          (cx:cpp val1) ") "
          cpp-op
          " (" (cx:cpp val2) "))"
        )   
      )   ; cpp sem-type
      ""  ; llvm sem-type
    )
  )
)

; Process andif, orif.
; SRC1 and SRC2 have any arithmetic mode.
; The result has mode BI.
; ??? May want to use INT as BI may introduce some slowness
; in the generated code.

(define (s-cpp-boolifop estate name cpp-op src1 src2 semantic-type)
  (let* ((val1 (rtl-cpp-get estate DFLT src1))
      (val2 (rtl-cpp-get estate DFLT src2)))

    ; If this is the simulator and MODE is not a host mode, use a macro.
    ; ??? MODE here being the mode of SRC1.  Maybe later.
    (if (string=? semantic-type "cpp")
      (cx:make (mode:lookup 'BI)
        (string-append "((" 
          (cx:cpp val1)
          ") " cpp-op
          " (" (cx:cpp val2) "))")
      )   ; cpp sem-type
      (error "LLVM IR code generation not yet implemented")  ; llvm sem-type
    )
  )
)

; Mode conversions.
(define (s-cpp-convop estate name mode s1 semantic-type)
  ; Get S1 in its normal mode, then convert.
  (let ((s (rtl-cpp-get estate DFLT s1))
      (mode (mode:lookup mode)))

    (if (string=? semantic-type "cpp") 
      (cx:make mode
        (string-append name "<"
          (gen-sem-mode-cpp-type (-rtx-sem-mode mode)) ">"
          "(" (cx:cpp s) ")"
        )
      )
    )   ; cpp sem-type
    (error "LLVM IR code generation not yet implemented")  ; llvm sem-type
  )
)

; Compare SRC1 and SRC2 in mode MODE.  The result has mode BI.

(define (s-cpp-cmpop estate name cpp-op mode src1 src2 semantic-type)
  (let* ((val1 (rtl-cpp-get estate mode src1))
      ; Refetch mode in case it was DFLT.
      (mode (cx:mode val1))
      (val2 (rtlc-c-get estate mode src2)))

    (if (string=? semantic-type "cpp")
      (cx:make (mode:lookup 'BI)
        (string-append "(("
          (cx:cpp val1)
          ") " cpp-op " ("
          (cx:cpp val2)
          "))"
        )
      )   ; cpp sem-type
      (error "LLVM IR code generation not yet implemented")  ; llvm sem-type
    )
  )
)

; `if' in RTL has a result, like ?: in C.
; We support both: one with a result (non VOID mode), and one without (VOID mode).
; The non-VOID case must have an else part.
; MODE is the mode of the result, not the comparison.
; The comparison is expected to return a zero/non-zero value.
; ??? Perhaps this should be a syntax-expr.  Later.

(define (s-cpp-if estate mode semantic-type cond then . else)
  (if (> (length else) 1)
    (error: "if: too many elements in 'else' part" else))

  (if (string=? semantic-type "cpp")
    (let ()
      (if (or (mode:eq? 'DFLT mode)
              (mode:eq? 'VOID mode))
        (cx:make mode
          (string-append "if (" (cx:cpp (rtl-cpp-get estate DFLT cond)) ")"
              " {\n" (cx:cpp (rtl-cpp-get estate mode then)) "}"
              (if (not (null? else))
                (string-append " else {\n"
                  (cx:cpp (rtl-cpp-get estate mode (car else)))
                  "}\n"
                )
                "\n"
              )
          )
        )
        (if (= (length else) 1)
          (cx:make mode
            (string-append "(("
              (cx:cpp (rtl-cpp-get estate DFLT cond))
              ") ? ("
              (cx:cpp (rtl-cpp-get estate mode then))
              ") : ("
              (cx:cpp (rtl-cpp-get estate mode (car else)))
              "))"
            )
          )
          (error "non-VoidMode `if' must have `else' part")
        )
      )
    )   ; cpp sem-type
    (error "LLVM IR code generation not yet implemented")  ; llvm sem-type
  )
)

; A multiway `if'.
; If MODE is VOID emit a series of if/else's.
; If MODE is not VOID, emit a series of ?:'s.
; COND-CODE-LIST is a list of lists, each sublist is a list of two elements:
; condition, code.  The condition part must return a zero/non-zero value, and
; the code part is treated as a `sequence'.
; This defer argument evaluation, the syntax
; ((... condition ...) ... action ...)
; needs special parsing.
; FIXME: Need more error checking of arguments.

(define (s-cpp-cond estate mode semantic-type . cond-code-list)
  (let ((vm? (or (mode:eq? 'DFLT mode) (mode:eq? 'VOID mode))))
    (if (null? cond-code-list)
      (error "empty `cond'")
    )
    (if (string=? semantic-type "cpp")  
      (let ((if-part (if vm?  "if (" "("))
          (then-part (if vm? ") " ") ? "))
          (elseif-part (if vm? " else if (" " : ("))
          (else-part (if vm? " else " " : ")) 
          (fi-part (if vm? "" ")")))
        
        (let loop 
            ((result
              (string-append
                if-part
                (cx:cpp (rtl-cpp-get estate DFLT (caar cond-code-list)))
                then-part
                (cx:cpp (apply s-cpp-sequence
                (cons estate
                  (cons mode
                  (cons nil
                  (cdar cond-code-list))))))))
             (ccl (cdr cond-code-list)))
    
          (cond 
            ((null? ccl) (cx:make mode result))
            ((eq? (caar ccl) 'else)
              (cx:make mode
                (string-append
                  result
                  else-part
                  (cx:cpp (apply s-cpp-sequence
                    (cons estate
                    (cons mode
                    (cons nil
                    (cdar ccl)))))
                  )
                )
              )
            )
            (else 
              (loop (string-append
                  result
                  elseif-part
                  (cx:cpp (rtl-cpp-get estate DFLT (caar ccl)))
                  then-part
                  (cx:cpp (apply s-cpp-sequence
                  (cons estate
                    (cons mode
                    (cons nil
                    (cdar ccl)))))))
                (cdr ccl)
              )
            )
          )
        )
      )   ; cpp sem-type
      (error "LLVM IR code generation not yet implemented")  ; llvm sem-type
    )
  )
)

; Utility of s-case to print a case prefix (for lack of a better term).

(define (-gen-cpp-case-prefix val)
  (string-append "  case "
    (cond 
      ((number? val) (number->string val))
      ((symbol? val) (string-upcase (gen-c-symbol val))) ; yes, upcase
      ((string? val) val)
      (else (parse-error "case:" "bad case" val))
    ) " : "
  )
)

; Utility of s-case to handle a void result.

(define (s-cpp-case-vm estate test case-list)
  (cx:make VOID
    (string-append
      "  switch ("
      (cx:cpp (rtl-cpp-get estate DFLT test))
      ")\n"
      "  {\n"
      (string-map 
        (lambda (case-entry)
          (let ((caseval (car case-entry))
              (code (cdr case-entry)))
            
            (string-append
              (cond 
                ((list? caseval) 
                  (string-map -gen-case-prefix caseval))
                ((eq? 'else caseval)
                  (string-append "  default : "))
                (else
                  (-gen-case-prefix caseval))
              )
              (cx:cpp (apply s-cpp-sequence
                (cons estate (cons VOID (cons nil code)))))
              "    break;\n"
            )
          )
        )
        case-list)
      "  }\n"
    )
  )
)

; Utility of s-case-non-vm to generate code to perform the test.

(define (-gen-cpp-non-vm-case-test estate mode test cases)
  (assert (not (null? cases)))
  (let loop ((result "") (cases cases))
    (if (null? cases)
      result
      (let (
          (case 
            (cond 
              ((number? (car cases)) (car cases))
              ((symbol? (car cases))
                (if (enum-lookup-val (car cases))
                  (rtx-make 'enum mode (car cases))
                  (context-error (estate-context estate)
                    "symbol not an enum" (car cases))
                )
              )
              (else (error "invalid case" (car cases)))
            )
          ))
        
        (loop 
          (string-append
            result
            (if (= (string-length result) 0)
              ""
              " || "
            )
            (cx:cpp (rtl-cpp-get estate mode test))
            " == "
            (cx:cpp (rtl-cpp-get estate mode case))
          )
          (cdr cases)
        )
      )
    )
  )
)

; Utility of s-case to handle a non-void result.
; This is expanded as a series of ?:'s.

(define (s-cpp-case-non-vm estate mode test case-list)
  (let ((if-part "(")
      (then-part ") ? ")
      (elseif-part " : (")
      (else-part " : ")
      (fi-part ")"))
    
    (let loop (
        (result
          (string-append
            if-part
            (-gen-non-vm-case-test estate mode test (caar case-list))
            then-part
            (cx:cpp (apply s-cpp-sequence
              (cons estate
              (cons mode
              (cons nil
              (cdar case-list))))))))
        (cl (cdr case-list)))

      (cond 
        ((null? cl) (cx:make mode result))
        ((eq? (caar cl) 'else)
          (cx:make mode
            (string-append
              result
              else-part
              (cx:cpp (apply s-cpp-sequence
                (cons estate
                (cons mode
                (cons nil
                  (cdar cl))))))
            )
          )
        )
        (else 
          (loop 
            (string-append
              result
              elseif-part
              (-gen-non-vm-case-test estate mode test (caar cl))
              then-part
              (cx:cpp (apply s-cpp-sequence
                (cons estate
                (cons mode
                (cons nil
                (cdar cl)))))
              )
            )
            (cdr cl)
          )
        )
      )
    )
  )
)

; C++ switch statement
; To follow convention, MODE is the first arg.
; FIXME: What to allow for case choices is wip.

(define (s-cpp-case estate mode semantic-type test . case-list)
  (if (string=? semantic-type "cpp")  
    (if (or (mode:eq? 'DFLT mode) (mode:eq? 'VOID mode))
        (s-case-vm estate test case-list)
        (s-case-non-vm estate mode test case-list)
    )   ; cpp sem-type
    (error "LLVM IR code generation not yet implemented")  ; llvm sem-type
  )
)

; Parallels and Sequences

; Temps for `parallel' are recorded differently than for `sequence'.
; For in-place C++ code generation only.

(define -cpp-par-temp-list nil)

; Record a temporary needed for a parallel in mode MODE.
; We just need to record the mode with a unique name so we use a <c-expr>
; object where the "expression" is the variable's name.

(define (-cpp-par-new-temp! mode)
  (set! -cpp-par-temp-list
    (cons 
      (cx:make mode 
        (string-append "temp"
          (number->string
            (length -cpp-par-temp-list)))
        )
      -cpp-par-temp-list
    )
  )
  (car -cpp-par-temp-list)
)

; Return the next temp from the list, and leave the list pointing to the
; next one.

(define (-cpp-par-next-temp!)
  (let ((result (car -cpp-par-temp-list)))
    
    (set! -cpp-par-temp-list (cdr -cpp-par-temp-list))
    result
  )
)

(define (-gen-cpp-par-temp-defns temp-list)
  ;(display temp-list) (newline)
  (string-append
    "  "
    ; ??? mode:c-type
    (string-map 
      (lambda (temp) 
        (string-append 
          (gen-sem-mode-cpp-type (cx:mode temp))
          " " (cx:cpp temp) ";"
        )
      ) 
      temp-list
    )
    "\n"
  )
)

; Parallels are handled by converting them into two sequences.  The first has
; all set destinations replaced with temps, and the second has all set sources
; replaced with those temps.
; ??? Revisit later to see if (if ...) and (set pc ...) is ok.
; How about disallowing if's and jump's inside parallels?
; One can still put a parallel inside an `if' however.

(define (-cpp-par-replace-set-dests estate exprs)
  (let ((sets (list 'set 'set-quiet
          (rtx-lookup 'set) (rtx-lookup 'set-quiet))))
      (letrec ((replace
        (lambda (expr)
          (let ((name (car expr))
              (options (rtx-options expr))
              (mode (rtx-mode expr)))
            
            (if (memq name sets)
              (list name
                options
                mode
                (-cpp-par-new-temp! ; replace dest with temp
                  (if (mode:eq? 'DFLT mode)
                    (rtx-lvalue-mode-name estate (rtx-set-dest expr))
                    mode)
                )
                (rtx-set-src expr)
              )
              (cons name
                (cons options
                  (cons mode (replace (rtx-args expr)))
                )
              )
            )
          )
        )
        ))
        (map replace exprs)
      )
  )
)

; This must process expressions in the same order as -cpp-par-replace-set-dests!

(define (-cpp-par-replace-set-srcs estate exprs)
  (let ((sets (list 'set 'set-quiet
          (rtx-lookup 'set) (rtx-lookup 'set-quiet))))
      (letrec (
        (replace
          (lambda (expr)
            (let ((name (car expr))
                (options (rtx-options expr))
                (mode (rtx-mode expr)))
              
              (if (memq name sets)
                (list name
                  options
                  mode
                  (rtx-set-dest expr)
                  (-cpp-par-next-temp!)
                ) ; the source's temp
                (cons name
                  (cons options
                    (cons mode (replace (cddr expr)))))
              )
            )
          )
        ))
        (map replace exprs)
      )
  )
)

; Return a <cpp-expr> node for a `parallel'.

(define (s-cpp-parallel estate semantic-type . exprs)
  (if (string=? semantic-type "cpp")
    (begin
      ; Initialize -par-temp-list for -par-replace-set-dests.
      (set! -cpp-par-temp-list nil)
      (let* (
          (set-dests 
            (string-map 
              (lambda (e)
                (rtl-cpp-with-estate estate VOID e))
              (-cpp-par-replace-set-dests estate exprs)
            ))
          (temps (reverse! -cpp-par-temp-list)))


        ; Initialize -par-temp-list for -par-replace-set-srcs.
        (set! -cpp-par-temp-list temps)
        (cx:make VOID
          (string-append
            ; FIXME: do {} while (0); doesn't get "optimized out"
            ; internally by gcc, meaning two labels and a loop are
            ; created for it to have to process.  We can generate pretty
            ; big files and can cause gcc to require *lots* of memory.
            ; So let's try just {} ...
            "{\n"
            (-gen-cpp-par-temp-defns temps)
            set-dests
            (string-map 
              (lambda (e) (rtl-cpp-with-estate estate VOID e))
              (-cpp-par-replace-set-srcs estate exprs))
            "}\n"
          )
        )
      )
    )   ; cpp sem-type
    (error "LLVM IR code generation not yet implemented") ; llvm sem-type
  )
)

; Return a <cpp-expr> node for a `sequence'.

(define (s-cpp-sequence estate mode semantic-type env . exprs)
  (if (string=? semantic-type "cpp")
    (let* ((env (rtx-env-make-locals env)) ; compile env
        (estate (estate-push-env estate env)))
      
      (if (or (mode:eq? 'DFLT mode)
              (mode:eq? 'VOID mode))
        
        (cx:make mode
          (string-append 
            ; FIXME: do {} while (0); doesn't get "optimized out"
            ; internally by gcc, meaning two labels and a loop are
            ; created for it to have to process.  We can generate pretty
            ; big files and can cause gcc to require *lots* of memory.
            ; So let's try just {} ...
            "{\n"
            (gen-temp-defs estate env)
            (string-map 
              (lambda (e)
                (rtl-cpp-with-estate estate DFLT e)
              )
              exprs
            )
            "}\n"
          )
        )
        (cx:make mode
          (string-append
            ; Don't use GCC extension unless necessary.
            (if (rtx-env-empty? env) "(" "({ ")
            (gen-temp-defs estate env)
            (string-drop 2
              (string-map
                (lambda (e)
                  (string-append
                    (if (rtx-env-empty? env) ", " "; ")
                    ; Strip off gratuitous ";\n" at end of expressions that
                    ; misguessed themselves to be in statement context.
                    ; See s-c-call, s-c-call-raw above.
                    (let ((substmt (rtl-cpp-with-estate estate DFLT e)))
                      
                      (if (and (rtx-env-empty? env)
                          (string=? (string-take -2 substmt) ";\n"))
                        
                        (string-drop -2 substmt)
                        substmt
                      )
                    )
                  )
                )
              exprs)
            )
            (if (rtx-env-empty? env) ")" "; })")
          )
        )
      )
    ) ; cpp sem-type
    (error "LLVM IR code generation not yet implemented") ; llvm sem-type
  )
)

; ============ RTL->CPP/LLVM IR generators ============

; Return code to set FN as the generator for RTX.

(defmacro define-fn (rtx args expr . rest)
  `(begin
     (assert (rtx-lookup (quote ,rtx)))
     (vector-set! table (rtx-num (rtx-lookup (quote ,rtx)))
      (lambda ,args ,@(cons expr rest))))
)

; This file portion is one big function to return the rtl->cpp
; lookup table.
; SEMANTIC-TYPE is a string specifying the desired semantic type
; for the code generators. Look at <rtl-cpp-eval-state>:semantic-type
; documentation for supported semantic types. 

(define (rtl-cpp-build-table)
  (let ((table (make-vector (rtx-max-num) #f)))

; Error generation.

(define-fn error (estate mode semantic-type message)
  ; NOT YET IMPLEMENTED. REQUIRES C-CALL SUPPORT
  (cx:make mode ";") ; Returns empty statement
)

; Enum support

(define-fn enum (estate option mode name)
  (cx:make mode (string-upcase (sanitize-elm-name name)))
)

; Instruction field support.

(define-fn ifield (estate options mode ifld-name)
  (cx:make 'UINT (sanitize-elm-name ifld-name))
)

; Operand support

(define-fn operand (estate options mode object-or-name)
  (cond 
    ((operand? object-or-name) object-or-name)
    ((symbol? object-or-name)
      (let ((object (current-op-lookup object-or-name)))
        
        (if (not object)
          (context-error (estate-context estate)
            "undefined operand" object-or-name))
        object
      )
    )
    (else
      (context-error (estate-context estate)
        "bad arg to `operand'" object-or-name))
  )
)

; The then branch refers to SID-SIMULATOR. Do we need to check that here?
; Perform checks on eventual error due to its removal.
(define-fn xop (estate options mode object) 
  (let ((delayed (assoc '#:delay (estate-modifiers estate))))
    
    (if (and delayed
          (equal? APPLICATION 'SID-SIMULATOR)
          (operand? object))
      ;; if we're looking at an operand inside a (delay ...) rtx, then we
      ;; are talking about a _delayed_ operand, which is a different
      ;; beast.  rather than try to work out what context we were
      ;; constructed within, we just clone the operand instance and set
      ;; the new one to have a delayed value. the setters and getters
      ;; will work it out.
      (let ((obj (object-copy object))
          (amount (cadr delayed)))
        
        (op:set-delay! obj amount)
        obj
      )
      ;; else return the normal object
      object
    )
  )
)

(define-fn local (estate options mode object-or-name)
  (cond 
    ((rtx-temp? object-or-name) object-or-name)
    ((symbol? object-or-name)
      (let ((object (rtx-temp-lookup (estate-env estate) object-or-name)))
        
        (if (not object)
          (context-error (estate-context estate)
            "undefined local" object-or-name)
        )
        object
      )
    )
    (else
      (context-error (estate-context estate)
        "bad arg to `local'" object-or-name)
    )
  )
)

(define-fn reg (estate options mode hw-elm . indx-sel)
  (let ((indx (or (list-maybe-ref indx-sel 0) 0))
      (sel (or (list-maybe-ref indx-sel 1) hw-selector-default)))
    
    (s-hw estate mode hw-elm indx sel)
  )
)

(define-fn raw-reg (estate options mode hw-elm . indx-sel)
  (let ((indx (or (list-maybe-ref indx-sel 0) 0))
      (sel (or (list-maybe-ref indx-sel 1) hw-selector-default)))
    
    (let ((result (s-hw estate mode hw-elm indx sel)))
      
      (obj-cons-attr! result (bool-attr-make 'RAW #t))
      result
    )
  )
)

(define-fn mem (estate options mode addr . sel)
  (s-hw estate mode 'h-memory addr
    (if (pair? sel) (car sel) hw-selector-default)
  )
)

(define-fn pc (estate options mode)
  s-pc
)

; Is this present in any decoder file? What is referenced?
(define-fn ref (estate options mode name)
  (if (not (insn? (estate-owner estate)))
    (error "ref: not processing an insn"))
  (cx:make 'UINT
    (string-append
      "(referenced & (1 << "
      (number->string
        (op:num (insn-lookup-op (estate-owner estate) name)))
    "))"
    )
  )
)

; ??? Maybe this should return an operand object.
(define-fn index-of (estate options mode op)
  (send (op:index (rtx-eval-with-estate op 'DFLT estate)) 'cxmake-get estate 'DFLT)
)

(define-fn clobber (estate options mode object)
  (cx:make VOID "; /*clobber*/\n")
)

; Is this even useful for our translators?

(define-fn delay (estate options mode num-node rtx)
  (case APPLICATION
    ((SID-SIMULATOR)
     (let* ((n (cadddr num-node))
      (old-delay (let ((old (assoc '#:delay (estate-modifiers estate))))
       (if old (cadr old) 0)))
      (new-delay (+ n old-delay)))    
       (begin
   ;; check for proper usage
       (if (let* ((hw (case (car rtx) 
        ((operand) (op:type (rtx-operand-obj rtx)))
        ((xop) (op:type (rtx-xop-obj rtx)))
        (else #f))))                 
         (not (and hw (or (pc? hw) (memory? hw) (register? hw)))))
       (context-error 
        (estate-context estate) 
        (string-append 
         "(delay ...) rtx applied to wrong type of operand '" (car rtx) "'. should be pc, register or memory")))
   ;; signal an error if we're delayed and not in a "parallel-insns" CPU
   (if (not (with-parallel?)) 
       (context-error         
        (estate-context estate) 
        "delayed operand in a non-parallel cpu"))
   ;; update cpu-global pipeline bound
   (cpu-set-max-delay! (current-cpu) (max (cpu-max-delay (current-cpu)) new-delay))      
   ;; pass along new delay to embedded rtx
   (rtx-eval-with-estate rtx mode (estate-with-modifiers estate `((#:delay ,new-delay)))))))

    ;; not in sid-land
  (else (s-sequence (estate-with-modifiers estate '((#:delay))) VOID '() rtx)))
)

(define-fn skip (estate options mode yes?)
  (send pc 'cxmake-skip estate yes?)
)

(define-fn eq-attr (estate options mode obj attr-name value)
  ; NOT YET IMPLEMENTED. Is it necessary?
  (cx:make 'INT ";") ; Returns empty statement
)

(define-fn attr (estate options mode owner attr-name)
  ; NOT YET IMPLEMENTED. Is it necessary?
  (cx:make 'INT ";") ; Returns empty statement
)

(define-fn const (estate options mode c)
  (assert (not (mode:eq? 'VOID mode)))
  (if (mode:eq? 'DFLT mode)
      (set! mode 'INT))
  (let ((mode (mode:lookup mode)))
    (cx:make mode
      (cond 
        ((and (<= #x-80000000 c) (> #x80000000 c))
          (number->string c))
        ((and (<= #x80000000 c) (>= #xffffffff c))
          (string-append "0x" (number->string c 16)))
        ; Else punt.
        (else (number->string c))
      )
    )
  )
)


(define-fn join (estate options out-mode in-mode arg1 . arg-rest)
  ; NOT YET IMPLEMENTED. 
  (cx:make 'VOID ";") ; Returns empty statement
)

(define-fn subword (estate options mode value word-num)
  ; NOT YET IMPLEMENTED. 
  (cx:make 'VOID ";") ; Returns empty statement
)

(define-fn c-code (estate options mode text)
  (cx:make mode text)
)

(define-fn c-call (estate options mode name . args)
  (apply s-cpp-c-call (cons estate (cons mode (cons name args))))
)

(define-fn c-raw-call (estate options mode name . args)
  (apply s-cpp-c-raw-call (cons estate (cons mode (cons name args))))
)

(define-fn nop (estate options mode)
  (cx:make VOID "((void) 0); /*nop*/\n")
)

(define-fn set (estate options mode dst src)
  (if (insn? (estate-owner estate))
    (rtl-cpp-set-trace estate mode dst (rtl-cpp-get estate mode src))
    (rtl-cpp-set-quiet estate mode dst (rtl-cpp-get estate mode src)))
)

(define-fn set-quiet (estate options mode dst src)
  (rtl-cpp-set-quiet estate mode dst (rtl-cpp-get estate mode src))
)

(define-fn neg (estate options mode s1)
  (s-cpp-unop estate "neg" "-" mode s1 "cpp")
)

(define-fn abs (estate options mode s1)
  (s-cpp-unop estate "abs" #f mode s1 "cpp")
)

(define-fn inv (estate options mode s1)
  (s-cpp-unop estate "inv" "~" mode s1 "cpp")
)

(define-fn not (estate options mode s1)
  (s-cpp-unop estate "not" "!" mode s1 "cpp")
)

(define-fn add (estate options mode s1 s2)
  (s-cpp-binop estate "add" "+" mode s1 s2 "cpp")
)
(define-fn sub (estate options mode s1 s2)
  (s-cpp-binop estate "sub" "-" mode s1 s2 "cpp")
)

; WRONG APPROACH for BINARY OPERATIONS. BETTER TO USE TEMPLATE
; FUNCTIONS TO INLINE. THIS APPEARS AS A OVERHEAD FOR SIMPLE
; BINARY OPERATIONS BUT IT'S MUCH CLEANER WHEN WE HAVE TO DEAL WITH
; COMPLEX OPERATIONS LIKE SQRT, SIN ETC...

(define-fn addc (estate options mode s1 s2 s3)
  (s-cpp-binop-with-bit estate "addC" mode s1 s2 s3 "cpp")
)
(define-fn add-cflag (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "addCF" mode s1 s2 s3 "cpp")
)
(define-fn add-oflag (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "addOF" mode s1 s2 s3 "cpp")
)
(define-fn subc (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "subC" mode s1 s2 s3 "cpp")
)
(define-fn sub-cflag (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "subCF" mode s1 s2 s3 "cpp")
)
(define-fn sub-oflag (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "subOF" mode s1 s2 s3 "cpp")
)

(define-fn mul (estate options mode s1 s2)
  (s-binop estate "mul" "*" mode s1 s2 "cpp")
)
(define-fn div (estate options mode s1 s2)
  (s-binop estate "div" "/" mode s1 s2 "cpp")
)
(define-fn udiv (estate options mode s1 s2)
  (s-binop estate "udiv" "/" mode s1 s2 "cpp")
)
(define-fn mod (estate options mode s1 s2)
  (s-binop estate "mod" "%" mode s1 s2 "cpp")
)
(define-fn umod (estate options mode s1 s2)
  (s-binop estate "umod" "%" mode s1 s2 "cpp")
)

(define-fn sqrt (estate options mode s1)
  (s-unop estate "SQRT" #f mode s1)
)
(define-fn cos (estate options mode s1)
  (s-unop estate "COS" #f mode s1)
)
(define-fn sin (estate options mode s1)
  (s-unop estate "SIN" #f mode s1)
)

(define-fn min (estate options mode s1 s2)
  (s-binop estate "MIN" #f mode s1 s2)
)
(define-fn max (estate options mode s1 s2)
  (s-binop estate "MAX" #f mode s1 s2)
)
(define-fn umin (estate options mode s1 s2)
  (s-binop estate "UMIN" #f mode s1 s2)
)
(define-fn umax (estate options mode s1 s2)
  (s-binop estate "UMAX" #f mode s1 s2)
)

(define-fn and (estate options mode s1 s2)
  (s-binop estate "AND" "&" mode s1 s2)
)
(define-fn or (estate options mode s1 s2)
  (s-binop estate "OR" "|" mode s1 s2)
)
(define-fn xor (estate options mode s1 s2)
  (s-binop estate "XOR" "^" mode s1 s2)
)

(define-fn sll (estate options mode s1 s2)
  (s-shop estate "SLL" "<<" mode s1 s2)
)
(define-fn srl (estate options mode s1 s2)
  (s-shop estate "SRL" ">>" mode s1 s2)
)
(define-fn sra (estate options mode s1 s2)
  (s-shop estate "SRA" ">>" mode s1 s2)
)
(define-fn ror (estate options mode s1 s2)
  (s-shop estate "ROR" #f mode s1 s2)
)
(define-fn rol (estate options mode s1 s2)
  (s-shop estate "ROL" #f mode s1 s2)
)

(define-fn andif (estate options mode s1 s2)
  (s-boolifop estate "ANDIF" "&&" s1 s2)
)
(define-fn orif (estate options mode s1 s2)
  (s-boolifop estate "ORIF" "||" s1 s2)
)

(define-fn ext (estate options mode s1)
  (s-convop estate "EXT" mode s1)
)
(define-fn zext (estate options mode s1)
  (s-convop estate "ZEXT" mode s1)
)
(define-fn trunc (estate options mode s1)
  (s-convop estate "TRUNC" mode s1)
)
(define-fn fext (estate options mode s1)
  (s-convop estate "FEXT" mode s1)
)
(define-fn ftrunc (estate options mode s1)
  (s-convop estate "FTRUNC" mode s1)
)
(define-fn float (estate options mode s1)
  (s-convop estate "FLOAT" mode s1)
)
(define-fn ufloat (estate options mode s1)
  (s-convop estate "UFLOAT" mode s1)
)
(define-fn fix (estate options mode s1)
  (s-convop estate "FIX" mode s1)
)
(define-fn ufix (estate options mode s1)
  (s-convop estate "UFIX" mode s1)
)

(define-fn eq (estate options mode s1 s2)
  (s-cmpop estate 'eq "==" mode s1 s2)
)
(define-fn ne (estate options mode s1 s2)
  (s-cmpop estate 'ne "!=" mode s1 s2)
)

(define-fn lt (estate options mode s1 s2)
  (s-cmpop estate 'lt "<" mode s1 s2)
)
(define-fn le (estate options mode s1 s2)
  (s-cmpop estate 'le "<=" mode s1 s2)
)
(define-fn gt (estate options mode s1 s2)
  (s-cmpop estate 'gt ">" mode s1 s2)
)
(define-fn ge (estate options mode s1 s2)
  (s-cmpop estate 'ge ">=" mode s1 s2)
)

(define-fn ltu (estate options mode s1 s2)
  (s-cmpop estate 'ltu "<" mode s1 s2)
)
(define-fn leu (estate options mode s1 s2)
  (s-cmpop estate 'leu "<=" mode s1 s2)
)
(define-fn gtu (estate options mode s1 s2)
  (s-cmpop estate 'gtu ">" mode s1 s2)
)
(define-fn geu (estate options mode s1 s2)
  (s-cmpop estate 'geu ">=" mode s1 s2)
)

(define-fn member (estate options mode value set)
  ; FIXME: Multiple evalutions of VALUE.
  (let ((c-value (rtl-c-get estate 'DFLT value))
  (set (rtx-number-list-values set)))
    (let loop ((set (cdr set))
         (code (string-append "(" (cx:c c-value)
            " == "
            (gen-integer (car set))
            ")")))
      (if (null? set)
    (cx:make (mode:lookup 'BI) (string-append "(" code ")"))
    (loop (cdr set)
    (string-append code
             " || ("
             (cx:c c-value)
             " == "
             (gen-integer (car set))
             ")")))))
)

(define-fn if (estate options mode cond then . else)
  (apply s-if (append! (list estate mode cond then) else))
)

(define-fn cond (estate options mode . cond-code-list)
  (apply s-cond (cons estate (cons mode cond-code-list)))
)

(define-fn case (estate options mode test . case-list)
  (apply s-case (cons estate (cons mode (cons test case-list))))
)

(define-fn parallel (estate options mode ignore expr . exprs)
  (apply s-parallel (cons estate (cons expr exprs)))
)

(define-fn sequence (estate options mode locals expr . exprs)
  (apply s-sequence
   (cons estate (cons mode (cons locals (cons expr exprs)))))
)

(define-fn closure (estate options mode expr env)
  ; ??? estate-push-env?
  (rtl-c-with-estate (estate-new-env estate env) DFLT expr)
)

; The result is the rtl->CPP generator table.
table
)) ; End of rtl-cpp-build-table

; ============ SEMANTIC-TYPE: CPP ============
; Emit CPP code for each rtx function.

; Table mapping rtx function to CPP generator.

(define -rtl-cpp-gen-table #f)

; Return the CPP generator for <rtx-func> F.

(define (rtl-cpp-generator f)
  (vector-ref -rtl-cpp-gen-table (rtx-num f))
)

(define (rtl-cpp-init!)
  (set! -rtl-cpp-gen-table (rtl-cpp-build-table "cpp"))
  *UNSPECIFIED*
)

; TODO: Populate cpp-gen-table
; TODO: Add a call to cpp-gen-table initialization in
;       cgen-ir.scm

; ============ SEMANTIC-TYPE: LLVM ============
; Emit LLVM code for each rtx function.

; Tablemapping rtx function to LLVM generator.

(define -rtl-llvm-gen-table #f)

; Return the CPP generator for <rtx-func> F.

(define (rtl-llvm-generator f)
  (vector-ref -rtl-llvm-gen-table (rtx-num f))
)

(define (rtl-llvm-init!)
  (set! -rtl-cpp-gen-table (rtl-cpp-build-table "llvm"))
  *UNSPECIFIED*
)

; TODO: Populate llvm-gen-table
; TODO: Add a call to llvm-gen-table initialization in
;       cgen-ir.scm